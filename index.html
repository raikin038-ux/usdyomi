<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>USD/JPY 15åˆ†è¶³ äºˆæ¸¬ï¼ˆMulti-Featureï¼‹BiLSTMï¼‹å¤–éƒ¨è¦å› ï½œXAUæ¬ æå¯¾å¿œï½œYahoo+AllOriginsï¼‹Retryï¼‹GPUï¼‹IndexedDBï¼‰</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Chart.js / TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>

<style>
  :root { --w: 1180px; }
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans",Meiryo,sans-serif; background:#fafafa; color:#222; margin:0; }
  header { padding:16px; background:#fff; border-bottom:1px solid #eee; }
  h1 { margin:0; font-size:20px; }
  main { max-width:var(--w); margin:0 auto; padding:12px; }
  .panel { background:#fff; border:1px solid #eee; border-radius:12px; padding:14px; margin:12px 0; }
  .row { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
  label { font-size:12px; color:#555; display:block; margin-bottom:4px; }
  input, button, select { font-size:14px; padding:8px 10px; }
  button { border:1px solid #ddd; background:#fff; border-radius:10px; cursor:pointer; }
  button.primary { background:#222; color:#fff; border-color:#222; }
  #status { font-size:12px; color:#555; white-space:pre-line; }
  .stats { display:flex; flex-wrap:wrap; gap:12px; }
  .stat { flex:1 1 260px; background:#f7f7f9; border-radius:10px; padding:12px; }
  .stat b { display:block; font-size:12px; color:#666; margin-bottom:6px; }
  .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; background:#eef; color:#223; margin-left:8px; }
  .cards { display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
  .card { background:#fff; border:1px solid #eee; border-radius:12px; padding:14px; display:flex; flex-direction:column; gap:8px; }
  .card h3 { margin:0; font-size:16px; }
  .kv { font-size:22px; font-weight:700; }
  .muted { color:#666; font-size:12px; }
  .rationale { font-size:13px; color:#444; line-height:1.6; white-space:pre-line; }
  canvas { max-width:100%; }
  footer { text-align:center; font-size:12px; color:#888; padding:16px; }
  @media (max-width: 980px){ .cards { grid-template-columns: 1fr; } }

  /* é€²æ—ãƒãƒ¼ */
  .progress-box { margin-top:6px; }
  .progress-label { font-size:12px; color:#555; margin-bottom:4px; }
  .progress-bar-bg { background:#eee; border-radius:6px; height:8px; width:100%; position:relative; }
  .progress-bar-fill { background:linear-gradient(90deg,#007bff,#00c6ff); height:100%; width:0%; border-radius:6px; transition:width .25s ease; }
  .progress-text { font-size:12px; text-align:right; margin-top:2px; color:#333; }

  /* ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹ */
  .net { display:flex; align-items:center; gap:8px; }
  .dot { width:10px; height:10px; border-radius:50%; background:#999; box-shadow:0 0 0 2px #fff inset; }
  .ok  { background:#20c997 !important; }
  .slow{ background:#f0ad4e !important; }
  .bad { background:#dc3545 !important; }
</style>

<!-- GPUè‡ªå‹•ï¼ˆWebGPUâ†’WebGLâ†’CPUï¼‰ -->
<script>
(async () => {
  if (typeof tf === "undefined") return;
  for (const b of ["webgpu","webgl","cpu"]) {
    try { await tf.setBackend(b); await tf.ready(); console.log(`âœ… TFJS backend=${b}`); document.title += ` | ${b.toUpperCase()}`; break; }
    catch (e) { console.warn(`fallback backend: ${b} ->`, e.message); }
  }
})();
</script>
</head>

<body>
<header>
  <h1>ğŸ’± USD/JPY 15åˆ†è¶³ äºˆæ¸¬ï¼ˆMulti-Featureï¼‹BiLSTMï¼‹å¤–éƒ¨è¦å› ï½œXAUæ¬ æå¯¾å¿œï½œYahoo+AllOriginsï¼‹Retryï¼‹GPUï¼‹IndexedDBï¼‰</h1>
</header>

<main>
  <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
  <div class="panel">
    <div class="row">
      <div><label>lookbackï¼ˆæœ¬ï¼‰</label><input id="lookback" type="number" min="32" value="64" /></div>
      <div><label>epochs</label><input id="epochs" type="number" min="5" value="18" /></div>
      <div><label>å­¦ç¿’ç‡</label><input id="lr" type="number" step="0.0001" value="0.001" /></div>
      <div><label>ä¿å­˜ä¸Šé™ï¼ˆIndexedDB ä»¶æ•°ï¼‰</label><input id="dbCap" type="number" min="5000" value="60000" /></div>
      <div><label>Yahoo ç¯„å›²</label>
        <select id="rangeSel">
          <option value="5d" selected>éå»5æ—¥ï¼ˆ15mï¼‰</option>
          <option value="1mo">éå»1ãƒ¶æœˆï¼ˆ15mï¼‰</option>
          <option value="3mo">éå»3ãƒ¶æœˆï¼ˆ15mï¼‰</option>
        </select>
      </div>
    </div>
    <div class="row" style="margin-top:10px;">
      <div><label>&nbsp;</label><button id="initBtn" class="primary">åˆæœŸå–å¾—ï¼ˆUSDJPY/DXY/XAU â†’ DBï¼‰</button></div>
      <div><label>&nbsp;</label><button id="startBtn">å­¦ç¿’ï¼‹äºˆæ¸¬ã‚’å®Ÿè¡Œ</button></div>
      <div><label>&nbsp;</label><button id="autoBtn">è‡ªå‹•æ›´æ–°: OFF</button></div>
      <div><label>æ›´æ–°æ–¹å¼</label>
        <select id="autoMode">
          <option value="adaptive" selected>15åˆ†å¢ƒç•Œã«åˆã‚ã›ã‚‹ï¼ˆæ¨å¥¨ï¼‰</option>
          <option value="fixed">å›ºå®šé–“éš”</option>
        </select>
      </div>
      <div><label>å›ºå®šé–“éš”ï¼ˆåˆ†ï¼‰</label><input id="intervalMin" type="number" min="1" value="1" /></div>
      <div><label>&nbsp;</label><button id="clearBtn">ä¿å­˜ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ï¼ˆIndexedDBï¼‰</button></div>
    </div>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
      <div id="status">æº–å‚™OKï¼šã€åˆæœŸå–å¾—ã€â†’ã€å­¦ç¿’ï¼‹äºˆæ¸¬ã€ã®é †ã§å®Ÿè¡Œã€‚XAUæ¬ æã§ã‚‚è‡ªå‹•è£œå®Œï¼†å†è©¦è¡Œã—ã¾ã™ã€‚</div>
      <div class="net"><div id="netDot" class="dot"></div><span id="netText" style="font-size:12px;color:#555;">æœªè¨ˆæ¸¬</span></div>
    </div>
  </div>

  <!-- æ¦‚æ³ -->
  <div class="panel">
    <div class="stats">
      <div class="stat"><b>æœ€æ–°15åˆ†ãƒãƒ¼ï¼ˆCloseï¼‰</b><span id="curPrice" class="kv">-</span> <span id="latestSrc" class="badge" style="display:none;"></span></div>
      <div class="stat"><b>å­¦ç¿’çŠ¶æ³</b><span id="trainState">idle</span></div>
      <div class="stat"><b>æœ€çµ‚å­¦ç¿’æå¤±ï¼ˆ15mï¼60mï¼240mï¼‰</b><span id="lossPack">- / - / -</span></div>
    </div>
  </div>

  <!-- 3ã‚«ãƒ¼ãƒ‰ -->
  <div class="cards">
    <div class="card" id="card15">
      <h3>çŸ­æœŸï¼š15åˆ†å¾Œ</h3>
      <div class="kv" id="pred15">-</div>
      <div class="muted" id="trend15">å‚¾å‘ï¼š-</div>
      <div class="rationale" id="rat15" style="display:none;"></div>
      <div class="progress-box">
        <div class="progress-label">å­¦ç¿’é€²è¡Œ</div>
        <div class="progress-bar-bg"><div class="progress-bar-fill" id="bar-15"></div></div>
        <div class="progress-text" id="text-15">0%</div>
      </div>
    </div>
    <div class="card" id="card60">
      <h3>ä¸­æœŸï¼š1æ™‚é–“å¾Œ</h3>
      <div class="kv" id="pred60">-</div>
      <div class="muted" id="trend60">å‚¾å‘ï¼š-</div>
      <div class="rationale" id="rat60" style="display:none;"></div>
      <div class="progress-box">
        <div class="progress-label">å­¦ç¿’é€²è¡Œ</div>
        <div class="progress-bar-bg"><div class="progress-bar-fill" id="bar-60"></div></div>
        <div class="progress-text" id="text-60">0%</div>
      </div>
    </div>
    <div class="card" id="card240">
      <h3>é•·æœŸï¼š4æ™‚é–“å¾Œ</h3>
      <div class="kv" id="pred240">-</div>
      <div class="muted" id="trend240">å‚¾å‘ï¼š-</div>
      <div class="rationale" id="rat240" style="display:none;"></div>
      <div class="progress-box">
        <div class="progress-label">å­¦ç¿’é€²è¡Œ</div>
        <div class="progress-bar-bg"><div class="progress-bar-fill" id="bar-240"></div></div>
        <div class="progress-text" id="text-240">0%</div>
      </div>
    </div>
  </div>

  <!-- ãƒãƒ£ãƒ¼ãƒˆ -->
  <div class="panel"><canvas id="chart" height="380"></canvas></div>
</main>

<footer>Â© USD/JPY 15m Predictor â€” BiLSTM + DXY & XAUï¼ˆæ¬ æè£œå®Œï¼‰ + Yahoo(AllOrigins) + Retry + IndexedDB + WebGPU</footer>

<script>
/* ========= Utils ========= */
const $ = (id)=>document.getElementById(id);
const log = (m)=>{ $("status").textContent = m; };
const appendLog = (m)=>{ $("status").textContent += "\\n" + m; };
const mean = (a)=> a.length? a.reduce((x,y)=>x+y,0)/a.length : 0;
const std  = (a)=> { if(!a.length) return 1e-8; const m = mean(a); const v= mean(a.map(v=> (v-m)*(v-m))); return Math.sqrt(v)||1e-8; };
const toHHMM = (d)=> new Date(d).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
const isNum  = (v)=> Number.isFinite(v);

/* ========= Network (Retry + Timeout + Indicator) ========= */
function setNet(statusMs, ok){
  const dot=$("netDot"), t=$("netText");
  if(!ok){ dot.className="dot bad"; t.textContent="å¤±æ•—"; return; }
  if(statusMs>2500){ dot.className="dot slow"; t.textContent=`é…å»¶ ${statusMs.toFixed(0)}ms`; }
  else { dot.className="dot ok"; t.textContent=`è‰¯å¥½ ${statusMs.toFixed(0)}ms`; }
}
async function fetchWithRetry(url, {timeout=12000, retries=2, backoff=900}={}){
  let err;
  for(let i=0;i<=retries;i++){
    const controller = new AbortController();
    const timer = setTimeout(()=>controller.abort(), timeout);
    const t0 = performance.now();
    try{
      const res = await fetch(url, {signal:controller.signal, cache:"no-store"});
      clearTimeout(timer);
      const dt = performance.now()-t0;
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      setNet(dt, true);
      const txt = await res.text();
      return { text: txt, latency: dt };
    }catch(e){
      clearTimeout(timer);
      err = e;
      setNet(performance.now()-t0, false);
      if(i<retries) await new Promise(r=>setTimeout(r, backoff*Math.pow(1.6,i)));
    }
  }
  throw err;
}

/* ========= Yahoo endpoints ========= */
function yChart(symbol, range="5d", interval="15m"){
  return `https://query1.finance.yahoo.com/v7/finance/chart/${encodeURIComponent(symbol)}?range=${range}&interval=${interval}&indicators=quote&includeTimestamps=true&_=${Date.now()}`;
}
const AO_raw = (url)=> `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
const AO_get = (url)=> `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

async function fetchYahooSeries(symbols, range="5d", interval="15m"){
  const errors=[];
  for(const sym of symbols){
    const targets = [
      {type:"direct", url:yChart(sym,range,interval)},
      {type:"raw",    url:AO_raw(yChart(sym,range,interval))},
      {type:"get",    url:AO_get(yChart(sym,range,interval)), wrapper:true}
    ];
    for(const t of targets){
      try{
        const {text} = await fetchWithRetry(t.url);
        const json = t.wrapper ? JSON.parse(JSON.parse(text).contents) : JSON.parse(text);
        const r = json?.chart?.result?.[0];
        const ts = r?.timestamp || [];
        const q  = r?.indicators?.quote?.[0] || {};
        if(!ts.length || !q?.close?.length) throw new Error("ãƒ‡ãƒ¼ã‚¿æ¬ è½");
        const rows=[];
        for(let i=0;i<ts.length;i++){
          const c=q.close[i]; if(!isNum(c)) continue;
          rows.push({
            ts: ts[i]*1000,
            open: Number(q.open?.[i] ?? c),
            high: Number(q.high?.[i] ?? c),
            low : Number(q.low ?. [i] ?? c),
            close:Number(c),
            hhmm: toHHMM(ts[i]*1000)
          });
        }
        if(rows.length){ appendLog(`${sym} å–å¾—: ${t.type} çµŒç”± ${rows.length}ä»¶`); return {symbol:sym, rows}; }
      }catch(e){ errors.push(`${sym}/${t?.type||"start"}: ${e.message}`); }
    }
  }
  throw new Error("Yahoo fetch failed: " + errors.slice(0,3).join(" | "));
}

/* ========= Fallback latest snapshot ========= */
async function fetchLatestFallback(){
  const tries = [
    async()=>{ const j=JSON.parse((await fetchWithRetry(`https://api.exchangerate.host/latest?base=USD&symbols=JPY&places=6`)).text); return {v:j?.rates?.JPY, src:"exchangerate.host"}; },
    async()=>{ const j=JSON.parse((await fetchWithRetry(`https://api.frankfurter.app/latest?from=USD&to=JPY`)).text); return {v:j?.rates?.JPY, src:"frankfurter.app"}; },
  ];
  for(const t of tries){
    try{ const {v,src}=await t(); if(isNum(v)) return {v,src}; }catch(e){}
  }
  throw new Error("æœ€æ–°å€¤å–å¾—å¤±æ•—");
}

/* ========= IndexedDB ========= */
let db;
const DB_NAME="usd_jpy_15m_db_pro_xau_safe", DB_VER=1, STORE="bars15";
function openDB(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,DB_VER);
  r.onupgradeneeded=e=>{const d=e.target.result; if(!d.objectStoreNames.contains(STORE)){ const s=d.createObjectStore(STORE,{keyPath:"ts"}); s.createIndex("by_ts","ts",{unique:true}); }};
  r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error||new Error("DB open error")); }); }
function withStore(db,mode,fn){ return new Promise((res,rej)=>{ const tx=db.transaction(STORE,mode); const s=tx.objectStore(STORE); const p=fn(s); tx.oncomplete=()=>res(p); tx.onerror=()=>rej(tx.error||new Error("TX error")); }); }
async function dbBulkPut(rows){ return withStore(db,"readwrite",s=>rows.forEach(b=>s.put(b))); }
async function dbAddBar(b){ return withStore(db,"readwrite",s=>s.put(b)); }
async function dbGetAll(){ return new Promise((res,rej)=>{ const out=[]; const tx=db.transaction(STORE,"readonly"); const s=tx.objectStore(STORE).index("by_ts"); s.openCursor().onsuccess=e=>{const c=e.target.result; if(c){out.push(c.value); c.continue();}}; tx.oncomplete=()=>res(out); tx.onerror=()=>rej(tx.error); }); }
async function dbCount(){ return withStore(db,"readonly",s=>new Promise((r,j)=>{ const c=s.count(); c.onsuccess=()=>r(c.result); c.onerror=()=>j(c.error);})); }
async function dbTrimOld(keep){ const total=await dbCount(); if(total<=keep) return; const rm=total-keep;
  await withStore(db,"readwrite",s=>new Promise((r,j)=>{ const idx=s.index("by_ts"); let n=0; idx.openCursor().onsuccess=e=>{const c=e.target.result; if(c&&n<rm){s.delete(c.primaryKey); n++; c.continue();} }; s.transaction.oncomplete=()=>r(); s.transaction.onerror=e=>j(e.target.error);})); }
async function dbClear(){ return withStore(db,"readwrite",s=>s.clear()); }

/* ========= Series in memory ========= */
let times15=[], closes15=[], opens15=[], highs15=[], lows15=[], timeTsArr=[];
let externalMap={}; // { ts(ms): {dxy, xau} }

/* ========= Indicators ========= */
function ema(arr, span){ const k=2/(span+1); let e=arr[0]; for(let i=1;i<arr.length;i++) e = arr[i]*k + e*(1-k); return e; }
function emaSeries(arr, span){ const out=[]; let e=arr[0]; const k=2/(span+1); for(let i=0;i<arr.length;i++){ e = i? (arr[i]*k + e*(1-k)) : arr[0]; out.push(e);} return out; }
function rsi(arr, period=14){ const out=new Array(arr.length).fill(null); if(arr.length<=period) return out;
  let gains=0,losses=0; for(let i=1;i<=period;i++){ const d=arr[i]-arr[i-1]; if(d>=0) gains+=d; else losses-=d; }
  let avgG=gains/period, avgL=losses/period; out[period]= 100 - 100/(1+(avgG/(avgL||1e-8)));
  for(let i=period+1;i<arr.length;i++){ const d=arr[i]-arr[i-1]; const g=Math.max(d,0), l=Math.max(-d,0);
    avgG=(avgG*(period-1)+g)/period; avgL=(avgL*(period-1)+l)/period;
    out[i]= 100 - 100/(1+(avgG/(avgL||1e-8)));
  } return out;
}
function macd(arr, fast=12, slow=26, signal=9){
  const emaF=emaSeries(arr,fast), emaS=emaSeries(arr,slow);
  const macdLine=emaF.map((v,i)=>v-(emaS[i]??v));
  const sigSeries=emaSeries(macdLine.map(v=>isNum(v)?v:0), signal);
  const sigAlign=macdLine.map((_,i)=>sigSeries[i] ?? sigSeries.at(-1) ?? 0);
  const hist=macdLine.map((v,i)=>(isNum(v)?v:0) - (sigAlign[i]??0));
  return { macdLine: macdLine.map(v=>isNum(v)?v:0), signalLine: sigAlign, hist };
}

/* ========= Feature engineering ========= */
function buildFeatureFrameFull(){
  const n = closes15.length;
  const frame = [];
  const delta = (i)=> (i>0 && isNum(closes15[i-1])) ? (closes15[i]/closes15[i-1] - 1) : 0;

  const ma5=[], ma20=[], vol5=[];
  for(let i=0;i<n;i++){
    const w5=closes15.slice(Math.max(0,i-4), i+1);
    const w20=closes15.slice(Math.max(0,i-19), i+1);
    ma5.push(mean(w5)); ma20.push(mean(w20)); vol5.push(std(w5));
  }
  const e5=emaSeries(closes15,5), e20=emaSeries(closes15,20);
  const emadiff=e5.map((v,i)=> (v - (e20[i]??v)));

  const hl_range = highs15.map((h,i)=> isNum(h)&&isNum(lows15[i]) ? (h - lows15[i]) : 0);
  const co_diff  = closes15.map((c,i)=> isNum(c)&&isNum(opens15[i]) ? (c - opens15[i]) : 0);
  const rsi14    = rsi(closes15,14);
  const mac      = macd(closes15,12,26,9);

  for(let i=0;i<n;i++){
    const price=closes15[i]; if(!isNum(price)) continue;
    frame.push({
      price,
      dlt: delta(i),
      ma5: ma5[i], ma20: ma20[i], vol5: vol5[i],
      emadiff: emadiff[i],
      open: opens15[i] ?? price,
      high: highs15[i] ?? price,
      low : lows15[i]  ?? price,
      hl_range: hl_range[i] ?? 0,
      co_diff : co_diff[i] ?? 0,
      rsi14   : isNum(rsi14[i]) ? rsi14[i] : 50,
      macd    : isNum(mac.macdLine[i]) ? mac.macdLine[i] : 0,
      macdsig : isNum(mac.signalLine[i])? mac.signalLine[i]: 0,
      dxy     : 0, dxy_dlt: 0,
      xau     : 0, xau_dlt: 0
    });
  }
  return frame;
}

// å¤–éƒ¨è¦å› ã‚’æ™‚åˆ»ãƒãƒ¼ã‚¸ï¼ˆæ¬ æã¯ç›´è¿‘å€¤ã§è£œå®Œï¼‰
function alignExternal(frame, extMap){
  const FIFTEEN=15*60*1000;
  let lastDXY=null, lastXAU=null;
  for(let i=0;i<frame.length;i++){
    const ts=timeTsArr[i];
    let hit=null, best=Infinity;
    for(const k in extMap){
      const diff=Math.abs(ts-Number(k));
      if(diff<=FIFTEEN && diff<best){ best=diff; hit=extMap[k]; }
    }
    if(hit){
      if(isNum(hit.dxy)) lastDXY=hit.dxy;
      if(isNum(hit.xau)) lastXAU=hit.xau;
    }
    // è£œå®Œï¼ˆç›´è¿‘å€¤ãŒç„¡ã‘ã‚Œã°å‰ã®frameã‹ã‚‰æ‹¾ã†ï¼ãã‚Œã‚‚ç„¡ã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—å€¤0ã§ã¯ãªãpriceã§ä»£ç”¨ï¼‰
    frame[i].dxy = isNum(lastDXY) ? lastDXY : (frame[i-1]?.dxy ?? frame[i].price);
    frame[i].xau = isNum(lastXAU) ? lastXAU : (frame[i-1]?.xau ?? frame[i].price);
  }
  for(let i=1;i<frame.length;i++){
    frame[i].dxy_dlt = isNum(frame[i-1].dxy) && frame[i-1].dxy!==0 ? (frame[i].dxy/frame[i-1].dxy - 1) : 0;
    frame[i].xau_dlt = isNum(frame[i-1].xau) && frame[i-1].xau!==0 ? (frame[i].xau/frame[i-1].xau - 1) : 0;
  }
  return frame;
}

/* ========= Normalization / dataset ========= */
function fitNorm(vec){
  const clean = vec.filter(v=>isNum(v));
  if(!clean.length) return { m:0, s:1 };
  return { m: mean(clean), s: std(clean)||1e-8 };
}
function makeXyFromFrame(frame, lookback, horizon, keys){
  const X=[], y=[];
  for(let i=0;i<frame.length - lookback - horizon; i++){
    const win=frame.slice(i, i+lookback);
    if(!keys.every(k=> win.every(r=>isNum(r[k])))) continue;
    const target=frame[i+lookback+horizon].price;
    if(!isNum(target)) continue;
    X.push(win.map(row => keys.map(k=>row[k])));
    y.push(target);
  }
  return {X,y};
}

/* ========= BiLSTM ========= */
function buildBiLSTM(inputLen, nFeat, lr){
  const m=tf.sequential();
  m.add(tf.layers.bidirectional({
    layer: tf.layers.lstm({units:64, returnSequences:true}),
    inputShape:[inputLen, nFeat]
  }));
  m.add(tf.layers.bidirectional({
    layer: tf.layers.lstm({units:32, returnSequences:false})
  }));
  m.add(tf.layers.dropout({rate:0.2}));
  m.add(tf.layers.dense({units:32, activation:"relu"}));
  m.add(tf.layers.dense({units:1}));
  m.compile({optimizer:tf.train.adam(lr), loss:"meanSquaredError"});
  return m;
}

/* ========= Progress bars ========= */
function updateProgressBar(label, progress, lossText){
  const map={ "15åˆ†":"15", "1æ™‚é–“":"60", "4æ™‚é–“":"240" };
  const key=map[label];
  const bar=$(`bar-${key}`), txt=$(`text-${key}`);
  if(bar) bar.style.width=`${Math.max(0,Math.min(100,progress))}%`;
  if(txt) txt.textContent = `${progress.toFixed(0)}%ã€€(loss=${lossText})`;
}

/* ========= Chart ========= */
let chart;
function drawChart(labels, values, preds={}){
  const canvas = $("chart");
  const existing = Chart.getChart(canvas);
  if (existing) existing.destroy();

  const labs=labels.slice();
  const datasets=[{ label:"USD/JPYï¼ˆ15åˆ†è¶³ Closeï¼‰", data:values, borderWidth:2, pointRadius:0, tension:0.2 }];

  const addPredPoint=(lbl,val,color="#f66")=>{
    if(!isNum(val)) return;
    labs.push(lbl);
    const arr=new Array(values.length + (labs.length-labels.length)).fill(null);
    arr[arr.length-1]=val;
    datasets.push({ label:`äºˆæ¸¬${lbl}`, data:arr, pointRadius:5, borderWidth:0, borderColor:color });
  };
  if(isNum(preds.m15)) addPredPoint("(+15åˆ†)", preds.m15);

  if(Array.isArray(preds.future) && preds.future.length){
    const arr=new Array(values.length).fill(null).concat(preds.future);
    const futLabels = preds.future.map((_,i)=>`+${(i+1)*15}m`);
    labs.push(...futLabels);
    datasets.push({ label:"1æ™‚é–“å…ˆ äºˆæ¸¬ãƒ©ã‚¤ãƒ³", data:arr, borderColor:"#e00000", borderDash:[6,3], tension:0.3, pointRadius:3 });
  }

  new Chart(canvas,{ type:"line", data:{labels:labs, datasets}, options:{ responsive:true, maintainAspectRatio:false } });
}

/* ========= Rationale ========= */
function linregSlope(arr){ const n=arr.length, mx=(n-1)/2, my=mean(arr); let num=0,den=0; for(let i=0;i<n;i++){const dx=i-mx; num+=dx*(arr[i]-my); den+=dx*dx;} return den?num/den:0; }
function rationaleText(winPrices, cur, pred, fLast){
  const minV=Math.min(...winPrices), maxV=Math.max(...winPrices), avg=mean(winPrices), vol=std(winPrices);
  const mom=winPrices.at(-1)-winPrices[0], slope=linregSlope(winPrices);
  const cross = (fLast.emadiff>0) ? "çŸ­æœŸ>é•·æœŸï¼ˆä¸Šæ˜‡ï¼‰" : (fLast.emadiff<0) ? "çŸ­æœŸ<é•·æœŸï¼ˆä¸‹é™ï¼‰" : "æ‹®æŠ—";
  const delta=pred-cur, bps=cur?(delta/cur*10000):0;
  const dxyP=(fLast.dxy_dlt*100).toFixed(2), xauP=(fLast.xau_dlt*100).toFixed(2);
  return `â€¢ å…¥åŠ›çª“: ${winPrices.length} æœ¬
â€¢ ä¾¡æ ¼ç¯„å›²: ${minV.toFixed(4)}ã€œ${maxV.toFixed(4)} / å¹³å‡ ${avg.toFixed(4)} / æ¨™æº–åå·® ${vol.toFixed(4)}
â€¢ å›å¸°å‚¾ã: ${slope.toFixed(6)} / ãƒ¢ãƒ¡ãƒ³ã‚¿ãƒ : ${mom>=0?"+":""}${mom.toFixed(4)}
â€¢ EMAå·®(5-20): ${fLast.emadiff>=0?"+":""}${fLast.emadiff.toFixed(5)} â†’ ${cross}
â€¢ äºˆæ¸¬å·®åˆ†: ${delta>=0?"+":""}${delta.toFixed(4)}ï¼ˆç´„ ${bps.toFixed(1)} bpsï¼‰
â€¢ å¤–éƒ¨è¦å› : DXYÎ”=${dxyP}%, XAUÎ”=${xauP}%`;
}

/* ========= Core Train & Predict ========= */
const keyIndex={}; // not used anymore but kept for clarity

async function trainAndPredictSingle(horizon, label, keep=false, keys){
  const lookback=parseInt($("lookback").value)||64;
  const epochs  =parseInt($("epochs").value)||18;
  const lr      =parseFloat($("lr").value)||0.001;

  let frame = buildFeatureFrameFull();
  frame = alignExternal(frame, externalMap);

  // å­¦ç¿’ç”¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
  const {X,y}=makeXyFromFrame(frame, lookback, horizon, keys);
  if(X.length<10){ throw new Error(`${label}: å­¦ç¿’ã‚µãƒ³ãƒ—ãƒ«ä¸è¶³(${X.length})`); }

  // æ­£è¦åŒ–
  // ç‰¹å¾´åˆ—ã”ã¨ã«flattenã—ã¦fit
  const nFeat=keys.length;
  const featCols = Array.from({length:nFeat}, (_,j)=> {
    const col=[]; for(const win of X){ for(const vec of win){ col.push(vec[j]); } }
    return col;
  });
  const fits = featCols.map(col=>fitNorm(col));
  const Xn = X.map(win=> win.map(vec => vec.map((v,j)=> (v - fits[j].m)/(fits[j].s||1e-8))));
  const fitY = fitNorm(y);
  const yn = y.map(v=>(v - fitY.m)/(fitY.s||1e-8));

  const tx=tf.tensor3d(Xn), ty=tf.tensor2d(yn,[yn.length,1]);
  const model=buildBiLSTM(lookback, nFeat, lr);

  updateProgressBar(label,0,"-"); $("trainState").textContent=`training (${label})`;
  const hist=await model.fit(tx,ty,{epochs,verbose:0,batchSize:Math.min(128,Math.max(16,Math.floor(Xn.length/10))),callbacks:{
    onEpochEnd:(e,logs)=>{ const loss = logs?.loss; updateProgressBar(label,(e+1)/epochs*100, isNum(loss)? loss.toFixed(4):"NaN"); }
  }});
  const lossVal=hist.history?.loss?.at(-1);
  const lossText = isNum(lossVal) ? (lossVal.toExponential?.(2) ?? String(lossVal)) : "NaN";
  updateProgressBar(label,100, lossText); $("trainState").textContent="idle";

  // 1ç‚¹äºˆæ¸¬
  const lastWin = frame.slice(-lookback).map(row => keys.map(k=>row[k]));
  const lastWinN= lastWin.map(vec=>vec.map((v,j)=>(v - fits[j].m)/(fits[j].s||1e-8)));
  const px=tf.tensor3d([lastWinN]);
  const pN=(await model.predict(px).array())[0][0];
  const pred = pN*(fitY.s||1e-8)+fitY.m;
  px.dispose(); tx.dispose(); ty.dispose();

  const lookPrices=closes15.slice(-lookback);
  const lastFeat=frame.at(-1);
  const cur=closes15.at(-1);
  const pack = {
    pred, loss: isNum(lossVal)?lossVal:NaN,
    trend: isNum(pred)&&isNum(cur) ? ((pred>cur)?"ä¸Šæ˜‡ ğŸ“ˆ":(pred<cur)?"ä¸‹é™ ğŸ“‰":"æ¨ªã°ã„ â–") : "-",
    rationale: rationaleText(lookPrices, cur, pred, lastFeat),
    model, fits, fitY, keys, frame, lookback
  };
  if(!keep){ model.dispose(); }
  return pack;
}

// æœªæ¥ n ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆ15åˆ†Ã—nï¼‰å†å¸°äºˆæ¸¬ï¼ˆå¤–éƒ¨è¦å› ã¯æ®ãˆç½®ãï¼‰
async function multiStepForecast(pack15, steps){
  const { model, fits, fitY, keys, frame, lookback } = pack15;
  let winFeat = frame.slice(-lookback).map(r=>({...r}));
  const preds=[];
  for(let i=0;i<steps;i++){
    const lastWinN = winFeat.map(vec => keys.map((k,j)=> (vec[k]-fits[j].m)/(fits[j].s||1e-8)));
    const px=tf.tensor3d([lastWinN]);
    const pN=(await model.predict(px).array())[0][0];
    const pred = pN*(fitY.s||1e-8)+fitY.m;
    preds.push(pred);
    px.dispose();

    // ä¾¡æ ¼ã‚’æ›´æ–°ï¼ˆå¤–éƒ¨è¦å› ã¯æœ€æ–°ã®ã¾ã¾ï¼‰
    const priceWindow = winFeat.map(v=>v.price).slice(1).concat(pred);
    const n=priceWindow.length;
    const win5=priceWindow.slice(-5), win20=priceWindow.slice(-20);
    const newRow = {
      ...winFeat.at(-1),
      price: pred,
      dlt: n>1? (priceWindow[n-1]/priceWindow[n-2]-1) : 0,
      ma5: mean(win5), ma20: mean(win20), vol5: std(win5),
      emadiff: ema(win5, Math.min(5,win5.length)) - ema(win20, Math.min(20,win20.length)),
    };
    winFeat = winFeat.slice(1).concat(newRow);
  }
  return preds;
}

/* ========= Chart/UI glue ========= */
function updateUIAfterPredict(pack, future){
  const { r15, r60, r240 } = pack;
  $("pred15").textContent = isNum(r15.pred)? r15.pred.toFixed(4) : "-";
  $("trend15").textContent = "å‚¾å‘ï¼š" + r15.trend;
  $("rat15").textContent = r15.rationale; $("rat15").style.display="block";

  $("pred60").textContent = isNum(r60.pred)? r60.pred.toFixed(4) : "-";
  $("trend60").textContent = "å‚¾å‘ï¼š" + r60.trend;
  $("rat60").textContent = r60.rationale; $("rat60").style.display="block";

  $("pred240").textContent = isNum(r240.pred)? r240.pred.toFixed(4) : "-";
  $("trend240").textContent = "å‚¾å‘ï¼š" + r240.trend;
  $("rat240").textContent = r240.rationale; $("rat240").style.display="block";

  const l15 = isNum(r15.loss)? r15.loss.toExponential(2):"NaN";
  const l60 = isNum(r60.loss)? r60.loss.toExponential(2):"NaN";
  const l240= isNum(r240.loss)? r240.loss.toExponential(2):"NaN";
  $("lossPack").textContent = `${l15} / ${l60} / ${l240}`;
  drawChart(times15, closes15, { m15:r15.pred, future });
}

/* ========= Pipeline ========= */
const USDJPY_SYM = ["USDJPY=X"];
const DXY_SYMS   = ["DX=F","DX-Y.NYB","^DXY"];
// XAU ã¯æœ€é•·ç³»åˆ—ã‚’é¸ã¶ï¼ˆè¤‡æ•°å€™è£œï¼‰
const XAU_CANDIDATES = [
  ["XAUUSD=X","GC=F","XAU=X"],        // ç¬¬1å€™è£œã‚°ãƒ«ãƒ¼ãƒ—
  ["GC=F","XAUUSD=X","XAU=X"]         // ç¬¬2ï¼ˆé †åºå…¥æ›¿ï¼‰ãƒªãƒˆãƒ©ã‚¤ç”¨
];

let autoHandle=null, adaptiveTimer=null;
function msUntilNext15m(){ const now=new Date(); const m=now.getUTCMinutes(); const add=15-(m%15); const next=new Date(now); next.setUTCMinutes(m+add,0,0); return Math.max(10_000,next-now); }
function msUntilNext15mChase(){ return Math.max(10_000, msUntilNext15m()+30_000); }

async function initialFetchToDB(){
  if(!db) db=await openDB();
  const range=$("rangeSel").value || "5d";
  log("Yahoo 15åˆ†è¶³ï¼ˆUSDJPY/DXY/XAUï¼‰ã‚’å–å¾—ä¸­â€¦");
  try{
    const usd = await fetchYahooSeries(USDJPY_SYM, range, "15m");
    await dbBulkPut(usd.rows);
    await dbTrimOld(parseInt($("dbCap").value)||60000);

    // DXY
    let dxyRows=null;
    try{ const dxyRes=await fetchYahooSeries(DXY_SYMS, range, "15m"); dxyRows=dxyRes.rows; }catch(e){ appendLog("DXYå–å¾—å¤±æ•—"); }

    // XAU: è¤‡æ•°æˆ¦ç•¥ã§æœ€é•·ã‚’æ¡ç”¨
    let xauRows=null, bestLen=0;
    for(const group of XAU_CANDIDATES){
      try{
        const r=await fetchYahooSeries(group, range, "15m");
        if(r.rows.length>bestLen){ xauRows=r.rows; bestLen=r.rows.length; }
      }catch(e){ /* try next */ }
    }
    if(!xauRows){ appendLog("XAUå–å¾—å¤±æ•—ï¼ˆå¾Œã§æœ€æ–°è¿½æ’ƒï¼‰"); }

    // å¤–éƒ¨è¦å› ãƒãƒƒãƒ—
    externalMap={};
    const pushExt=(arr,key)=>{ if(!arr) return; for(const r of arr){ externalMap[r.ts]={...(externalMap[r.ts]||{}), [key]:r.close}; } };
    pushExt(dxyRows, "dxy"); pushExt(xauRows,"xau");

    log(`âœ… åˆæœŸå–å¾—æˆåŠŸï¼šUSDJPY=${usd.rows.length}ä»¶ / DXY=${dxyRows?dxyRows.length:"-"} / XAU=${xauRows?xauRows.length:"-"}`);
  }catch(e){
    console.error(e);
    log("âš ï¸ åˆæœŸå–å¾—ã«å¤±æ•—ã€‚ä¸€éƒ¨ã®ã¿ä¿å­˜ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä»¥é™ã®å­¦ç¿’ã§fallbackå€¤ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚");
  }
  await loadFromDBToMemory();
}

async function loadFromDBToMemory(){
  const all=await dbGetAll();
  if(all.length){
    times15=all.map(r=>r.hhmm);
    opens15=all.map(r=>r.open); highs15=all.map(r=>r.high); lows15=all.map(r=>r.low);
    closes15=all.map(r=>r.close); timeTsArr=all.map(r=>r.ts);
    drawChart(times15, closes15, {});
    $("curPrice").textContent=isNum(closes15.at(-1))? closes15.at(-1).toFixed(4) : "-";
    log(`å¾©å…ƒï¼šDB ${all.length}ä»¶ã€‚`);
  }else{
    log("ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãªã—ã€‚ã€åˆæœŸå–å¾—ã€ã§å–ã‚Šè¾¼ã‚“ã§ãã ã•ã„ã€‚");
  }
}

async function appendLatestBar(){
  const lastHH=times15.at(-1);
  const now=new Date(); const rounded=new Date(now.getTime());
  rounded.setUTCMinutes(now.getUTCMinutes() - (now.getUTCMinutes()%15), 0, 0);
  const hhmm=toHHMM(rounded.getTime());
  if(lastHH===hhmm) return null;

  try{
    const usd = await fetchYahooSeries(USDJPY_SYM, "1d", "15m");
    const last=usd.rows.at(-1);
    if(last){
      await dbAddBar(last);
      times15.push(last.hhmm); opens15.push(last.open); highs15.push(last.high); lows15.push(last.low); closes15.push(last.close); timeTsArr.push(last.ts);
      $("latestSrc").style.display="inline-block"; $("latestSrc").textContent="æœ€æ–°: Yahoo 15m";
      // å¤–éƒ¨ã‚‚æ›´æ–°ãƒˆãƒ©ã‚¤
      try{
        const [dxyRes, xauTry1] = await Promise.allSettled([
          fetchYahooSeries(DXY_SYMS,"1d","15m"),
          fetchYahooSeries(["XAUUSD=X","GC=F","XAU=X"],"1d","15m")
        ]);
        if(dxyRes.status==="fulfilled"){ const r=dxyRes.value.rows.at(-1); externalMap[r.ts]={...(externalMap[r.ts]||{}), dxy:r.close}; }
        if(xauTry1.status==="fulfilled"){ const r=xauTry1.value.rows.at(-1); externalMap[r.ts]={...(externalMap[r.ts]||{}), xau:r.close}; }
      }catch(e){}
      return last.close;
    }
  }catch(e){ console.warn("Yahooæœ€æ–°å¤±æ•—â†’fallback", e.message); }

  try{
    const {v,src}=await fetchLatestFallback();
    const b={ts:rounded.getTime(), hhmm, open:v, high:v, low:v, close:v};
    await dbAddBar(b);
    times15.push(hhmm); opens15.push(v); highs15.push(v); lows15.push(v); closes15.push(v); timeTsArr.push(b.ts);
    $("latestSrc").style.display="inline-block"; $("latestSrc").textContent=`æœ€æ–°: ${src}`;
    return v;
  }catch(e){ console.error("æœ€æ–°ã‚‚å¤±æ•—", e.message); return null; }
}

async function trainAndPredictMulti(){
  const keys = [
    "price","dlt","ma5","ma20","vol5","emadiff",
    "open","high","low","hl_range","co_diff",
    "rsi14","macd","macdsig",
    "dxy","dxy_dlt","xau","xau_dlt"
  ];
  const r15  = await trainAndPredictSingle(1,  "15åˆ†", true,  keys);
  const r60  = await trainAndPredictSingle(4,  "1æ™‚é–“", false, keys);
  const r240 = await trainAndPredictSingle(16, "4æ™‚é–“", false, keys);
  const future = await multiStepForecast(r15, 4);
  r15.model.dispose();
  return { r15, r60, r240, future };
}

function updateAllUI(pack){
  updateUIAfterPredict(pack, pack.future);
}

async function oneCycle(){
  if(!db) db=await openDB();
  const v=await appendLatestBar();
  if(isNum(v)) $("curPrice").textContent=v.toFixed(4);

  const lookback=parseInt($("lookback").value)||64;
  if(closes15.length < (lookback + 30)){
    appendLog("ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã®ãŸã‚å­¦ç¿’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆåˆå›åé›†ä¸­ï¼‰");
    drawChart(times15, closes15, {});
    return;
  }
  try{
    const pack=await trainAndPredictMulti();
    updateAllUI(pack);
    log(`å®Œäº†ï¼šbars=${closes15.length} / ç¾åœ¨=${isNum(closes15.at(-1))?closes15.at(-1).toFixed(4):"-"}`);
    await dbTrimOld(parseInt($("dbCap").value)||60000);
  }catch(e){ console.error(e); appendLog("å­¦ç¿’ã‚¨ãƒ©ãƒ¼: " + e.message); }
}

/* ========= Auto update (adaptive/fixed) ========= */

$("autoBtn").onclick = async ()=>{
  const mode = $("autoMode").value;
  if(mode==="adaptive"){
    if(adaptiveTimer){ clearTimeout(adaptiveTimer); adaptiveTimer=null; $("autoBtn").textContent="è‡ªå‹•æ›´æ–°: OFF"; appendLog("è‡ªå‹•æ›´æ–°OFFï¼ˆé©å¿œå‹ï¼‰"); }
    else{
      if(times15.length===0) await loadFromDBToMemory();
      $("autoBtn").textContent="è‡ªå‹•æ›´æ–°: ON";
      appendLog("è‡ªå‹•æ›´æ–°ONï¼ˆé©å¿œå‹ï¼š15åˆ†å¢ƒç•Œã§æ›´æ–°ï¼‹è¿½æ’ƒãƒã‚§ãƒƒã‚¯ï¼‰");
      await oneCycle();
      const loop=async ()=>{ await oneCycle(); adaptiveTimer=setTimeout(loop, msUntilNext15mChase()); };
      adaptiveTimer=setTimeout(loop, msUntilNext15mChase());
    }
  }else{
    if(fixedTimer){ clearInterval(fixedTimer); fixedTimer=null; $("autoBtn").textContent="è‡ªå‹•æ›´æ–°: OFF"; appendLog("è‡ªå‹•æ›´æ–°OFFï¼ˆå›ºå®šï¼‰"); }
    else{
      if(times15.length===0) await loadFromDBToMemory();
      const m=Math.max(1, parseInt($("intervalMin").value)||1);
      $("autoBtn").textContent="è‡ªå‹•æ›´æ–°: ON";
      appendLog(`è‡ªå‹•æ›´æ–°ONï¼ˆå›ºå®šï¼š${m}åˆ†ï¼‰`);
      await oneCycle();
      fixedTimer=setInterval(oneCycle, m*60*1000);
    }
  }
};

/* ========= Buttons ========= */
$("initBtn").onclick = async ()=>{ if(!db) db=await openDB(); await initialFetchToDB(); };
$("startBtn").onclick = async ()=>{ if(!db) db=await openDB(); if(times15.length===0) await loadFromDBToMemory(); await oneCycle(); };
$("clearBtn").onclick = async ()=>{
  if(!db) db=await openDB();
  if(confirm("IndexedDBã®ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")){
    await dbClear();
    times15=[]; opens15=[]; highs15=[]; lows15=[]; closes15=[]; timeTsArr=[]; externalMap={};
    const c=Chart.getChart("chart"); if(c) c.destroy();
    $("curPrice").textContent="-"; $("lossPack").textContent="- / - / -";
    ["15","60","240"].forEach(s=>{ $(`pred${s}`).textContent="-"; $(`trend${s}`).textContent="å‚¾å‘ï¼š-"; $(`rat${s}`).style.display="none"; updateProgressBar(s==="15"?"15åˆ†":s==="60"?"1æ™‚é–“":"4æ™‚é–“",0,"-"); });
    log("IndexedDBã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸã€‚");
  }
};

/* ========= Startup ========= */
window.addEventListener("load", async ()=>{ db=await openDB(); await loadFromDBToMemory(); });
</script>
</body>
</html>
